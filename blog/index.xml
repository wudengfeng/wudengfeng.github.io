<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on 爬山的博客</title>
    <link>https://wudengfeng.github.io/blog/</link>
    <description>Recent content in Blogs on 爬山的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 24 Mar 2020 22:50:32 +0800</lastBuildDate>
    
	<atom:link href="https://wudengfeng.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>布隆过滤器</title>
      <link>https://wudengfeng.github.io/blog/bloom_filter/</link>
      <pubDate>Tue, 24 Mar 2020 22:50:32 +0800</pubDate>
      
      <guid>https://wudengfeng.github.io/blog/bloom_filter/</guid>
      <description>简介 布隆过滤器（Bloom Filter）是一种概率型数据结构。在允许一定误判的情况下，用于判断一个元素是否“可能在”，“一定不在”一个集合中。它由一个二进制向量和一系列哈希函数组成。
原理 首先我们准备一个bit array，将每一位都置为0。当我们需要添加一个元素到集合中时，使用n个hash函数取该元素的n个hash值，将每个hash值对bit array长度取模得到n个小于bit array长度的值，然后把bit array对应的这n个位置置为1，这样就完成了一次插入元素。当我们要判断某个元素是否在集合中，依然使用这n个hash函数，算出该元素在bit array中对应的n个位置，然后我们只要判断这n个位置是否都为1，如果都是1则说明该元素“可能”在集合中，否则“一定不在”集合中。
 为什么对应位都是1，是“可能”在集合中，这是因为不同元素算出来的hash值取模后的位数有可能是同一个位，导致出现该元素明明不在集合中，却被误判为在集合中。
 为什么对应位只要有一位不为1，就“一定不在”集合中，这是因为假设该元素在集合中，对应位一定会被置为1。
 这里我们就可以看出，布隆过滤器是会存在一定的误判的，但是只会有“假阳性”的情况。那么现在想想，一个布隆过滤器这样的误判率会是多少，由什么来决定误判率的大小呢？考虑这样的场景，当我们准备好一个bit array，长度为m，再准备n个函数函数组成一个布隆过滤器，当越来越多的元素进入，被置为1的位置越来越多，误判率也会升高，这时如果我们增加n的值，即使用更多的hash函数，每个元素的重叠位就会降低，可以缓解误判率的升高。又或者我们增加bit array的长度，允许更多的bit被置为1，也一样可以达到目的。所以误判率和bit array的长度还有hash函数的个数有关。具体的关系我们到下面再详细推导。
 rebuild过程。在业务使用中，我们往往都会固定好要使用的bit array长度和hash函数个数，当达到一定的误判率时，需要重新构建布隆过滤器。我们的选择是选用更长的bit array。将原来的bit array中置为1的位置映射到新的bit array中。
 这里有几个问题，为什么在误判率升高的情况下，不选用增加hash函数？因为再增加hash函数，需要重新计算每个元素的hash值，而我们又不知道原始元素的数据。 如何判定已经达到预期中的误判率？我们已经知道，误判率和bit array的长度m和hash函数个数n有关，我们可以在bit array前k个bit记录元素个数，当元素个数超过预期值，认为误判率到了预期的阈值。   rebuild的具体做法：//todo
特点 看了上面的介绍的原理，我们可以总结下布隆过滤器的特点
 使用bit array，大量节省空间 不存储原始数据 不可以删除，删除的话将n位的bit置为0，可能会影响到别的元素，因为别的元素计算的bit位也有可能是要被删除元素对应的位 存在一定的误判率，我们需要在业务场景和性能中找到平衡点，选取可以接受的误判率对应的bit array长度和hash函数个数 需要对逐渐增长的内容量做rebuild操作  代码实现 package main import ( &amp;quot;context&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;hash&amp;quot; &amp;quot;hash/fnv&amp;quot; &amp;quot;math/big&amp;quot; &amp;quot;github.com/spaolacci/murmur3&amp;quot; ) const ( Seed = 12138 BitNum = 8 BitExist uint = 1 BitNotExist uint = 0 ) type BloomFilter struct { Bits *big.</description>
    </item>
    
  </channel>
</rss>